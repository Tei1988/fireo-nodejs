/** Declaration file generated by dts-gen */

import { GeoPoint, Transaction } from "@google-cloud/firestore";

export class BaseField {
  constructor();

  configure(...args: any[]): void;

  getDBValue(...args: any[]): void;

  setDbValue(...args: any[]): void;

  setValue(...args: any[]): void;
}

type FirestoreTypes = string | number | Date;
interface ModelInitArgs {
  parent?: string;
}
interface ModelSaveArgs {
  merge?: boolean;
}
export class Model {
  constructor(...args: any[]);

  delete(...args: any[]): Promise<void>;

  fromObject(...args: any[]): void;

  save(args?: ModelSaveArgs): Promise<void>;

  toObject(...args: any[]): void;

  update(...args: any[]): Promise<void>;

  upsert(): Promise<void>;

  static fromObject<T>(args: { [key: string]: FirestoreTypes }): T;

  static init<T>(args?: ModelInitArgs): T;

  static parent(...args: any[]): void;

  static get collection(): Collection;
}

export function Field(...args: any[]): any;

export function Fireo(...args: any[]): any;

interface FieldArgs<T> {
  default?: T;
  required?: boolean;
  name?: string;
}
interface AutoFieldArgs {
  auto?: boolean;
}
interface AutoLoadFieldArgs {
  autoLoad?: boolean;
}
type FirebaseID = string;

export namespace Field {
  function Boolean(args?: FieldArgs<boolean>): boolean;

  function DateTime(args?: FieldArgs<Date> & AutoFieldArgs): Date;

  function GeoPoint(args?: FieldArgs<GeoPoint>): GeoPoint;

  function ID(): FirebaseID;

  function List<T>(args?: FieldArgs<T[]>): T[];

  function Map<T>(args?: FieldArgs<{ [key: string]: T }>): { [key: string]: T };

  function Number(args?: FieldArgs<number>): number;

  function Reference<T extends Model>(
    args?: FieldArgs<FirebaseID> & AutoLoadFieldArgs
  ): FirebaseID | { get: () => T };

  function Text(args?: FieldArgs<string>): string;
}

export namespace Fireo {
  function GeoPoint(lat: number, lng: number): GeoPoint;

  function batch(...args: any[]): void;

  function increment(...args: any[]): void;

  function listRemove(...args: any[]): void;

  function listUnion(...args: any[]): void;

  function runTransaction<T>(
    callback: (t: Transaction) => Promise<T>
  ): Promise<T>;

  namespace connection {
    const conn: {};

    const connection: {};

    function setting(...args: any[]): void;
  }
}

interface QueryIdentifierArgs {
  id?: string;
  key?: string;
}
interface TransactionArgs {
  transaction?: Transaction;
}
interface DeleteChildArgs {
  child?: boolean;
}
type CollectionGetArgs = QueryIdentifierArgs & TransactionArgs;
type CollectionDeleteArgs = QueryIdentifierArgs & DeleteChildArgs;
declare class Collection {
  constructor(modelObject: Model);

  cursor(...args: any[]): void;

  delete(args: CollectionDeleteArgs): Promise<void>;

  fetch<T>(...args: any[]): Promise<T[]>;

  get<T>(args: CollectionGetArgs): Promise<T>;

  limit(...args: any[]): void;

  limitToLast(...args: any[]): void;

  offset(...args: any[]): void;

  orderBy(...args: any[]): void;

  parent(...args: any[]): void;

  transaction(...args: any[]): void;

  where(field: string, operator: string, value: string): Query;
}

declare class Query {
  where(field: string, operator: string, value: string): Query;
}
