/** Declaration file generated by dts-gen */

import {
  GeoPoint,
  Transaction,
  WriteBatch,
  FieldValue,
  Settings,
  Firestore as CloudFirestore,
} from "@google-cloud/firestore";

type FirestoreID = string;
type FirestoreKey = string;
type IDOrKeyProps = { id: FirestoreID } | { key: FirestoreKey };
type TransactionOrBatchProp =
  | { transaction: Transaction }
  | { batch: WriteBatch };

type FirestorePrimitiveTypes = string | number | Date;
type FirestoreCollectionTypes =
  | FirestoreTypes[]
  | { [key: string]: FirestoreTypes };
type FirestoreTypes = FirestorePrimitiveTypes | FirestoreCollectionTypes;

export class Model {
  constructor(isInstantiate?: boolean);
  delete(options?: TransactionOrBatchProp): Promise<void>;
  fromObject(map: { [key: string]: FirestoreTypes }): this;
  toObject(): { [key: string]: FirestoreTypes };
  save(options?: { merge?: boolean } & TransactionOrBatchProp): Promise<void>;
  upsert(options?: TransactionOrBatchProp): Promise<void>;
  update(options?: IDOrKeyProps & TransactionOrBatchProp): Promise<void>;
  static fromObject<T>(map: { [key: string]: FirestoreTypes }): T;
  static init<T>(args?: { parent?: string, transaction?: Transaction }): T;
  static parent<T>(key: FirestoreKey): T;
  static get collection(): Collection;
}

declare class Collection {
  constructor(modelObject: Model);
  get<T>(options: IDOrKeyProps & { transaction?: Transaction }): Promise<T>;
  delete(by: IDOrKeyProps & { child?: boolean }): Promise<void>;
  where(field: string, operator: string, value: FirestoreTypes): Query;
  fetch<T>(limit: number): Promise<{ cursor: string; list: T[] }>;
  limit(number: number): Query;
  limitToLast(number: number): Query;
  orderBy(field: string): Query;
  cursor(queryCursor: string): Query;
  offset(number: number): Query;
  parent(key: string): Query;
  transaction(t: Transaction): Query;
}

declare class Query {
  constructor(collection: Collection);
  where(field: string, operator: string, value: FirestoreTypes): Query;
  limit(number: number): Query;
  limitToLast(number: number): Query;
  orderBy(field: string): Query;
  cursor(queryCursor: string): Query;
  offset(number: number): Query;
  parent(key: string): Query;
  transaction(t: Transaction): Query;
  delete(child: boolean): Promise<void>;
  fetch<T>(limit: number): Promise<{ cursor: string; list: T[] }>;
  get<T>(): Promise<T>;
}

interface FieldProps<T> {
  default?: T;
  required?: boolean;
  name?: string;
}
type IDField = () => FirestoreID;
type TextField = (
  options?: FieldProps<string> & { toLowercase?: boolean }
) => string;
type NumberField = (options?: FieldProps<number>) => number;
type BooleanField = (options?: FieldProps<boolean>) => boolean;
type ListField<T extends FirestoreTypes> = (options?: FieldProps<T[]>) => T[];
type MapField = (
  options?: FieldProps<{ [key: string]: FirestoreTypes }>
) => { [key: string]: FirestoreTypes };
type DateTimeField = (options?: FieldProps<Date> & { auto?: boolean }) => Date;
type GeoPointField = (options?: FieldProps<GeoPoint>) => GeoPoint;
type ReferenceField<T> = (
  options?: FieldProps<string> & { autoLoad?: boolean }
) => string | T;

export class Field {
  static ID: IDField;
  static Text: TextField;
  static Number: NumberField;
  static Boolean: BooleanField;
  static List<T extends FirestoreTypes>(options?: {}): T[];
  static Map: MapField;
  static DateTime: DateTimeField;
  static GeoPoint: GeoPointField;
  static Reference: ReferenceField;
}

declare class Firestore {
  constructor();
  setting(settings?: Settings): CloudFirestore;
  get conn(): CloudFirestore;
}

export class Fireo {
  static runTransaction<T>(
    callback: (t: Transaction) => Promise<T>
  ): Promise<void>;
  static batch(): WriteBatch;
  static GeoPoint(latitude: number, longitude: number): GeoPoint;
  static listUnion<T>(element: T): FieldValue;
  static listRemove<T>(element: T): FieldValue;
  static increment(number: number): FieldValue;
  static get connection(): Firestore;
}
